import { Timestamp } from 'firebase/firestore';
import { getCustomers } from './customer-service';
import { getUsersByCrew } from './user-service';
import type { Customer, User, DayOfWeek } from './firebase-types';

export interface AutoGeneratedSchedule {
  date: Date;
  crewId: string;
  crewMembers: User[];
  customers: Customer[];
  estimatedStartTime: string;
  estimatedEndTime: string;
  totalDistance: number;
  optimizedRoute: { lat: number; lng: number }[];
}

export interface ScheduleGenerationOptions {
  startDate: Date;
  endDate: Date;
  includeWeekends?: boolean;
  maxCustomersPerDay?: number;
  serviceBufferMinutes?: number;
}

/**
 * Automatically generates schedules based on:
 * 1. Customer service preferences (days, times)
 * 2. Crew availability and capabilities
 * 3. Service frequency and last service date
 * 4. Geographic proximity for route optimization
 */
export class AutoScheduleGenerator {
  private customers: Customer[] = [];
  private crews: Map<string, User[]> = new Map();

  constructor() {}

  /**
   * Initialize the generator with current data
   */
  async initialize(): Promise<void> {
    // Get all active customers
    this.customers = await getCustomers();
    
    // Get all crews and their members
    const allUsers = await getUsersByCrew();
    allUsers.forEach((crewMembers, crewId) => {
      this.crews.set(crewId, crewMembers);
    });
  }

  /**
   * Generate schedules for a date range
   */
  async generateSchedules(options: ScheduleGenerationOptions): Promise<AutoGeneratedSchedule[]> {
    const schedules: AutoGeneratedSchedule[] = [];
    const currentDate = new Date(options.startDate);

    while (currentDate <= options.endDate) {
      const daySchedules = await this.generateSchedulesForDate(currentDate, options);
      schedules.push(...daySchedules);
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return schedules;
  }

  /**
   * Generate schedules for a specific date
   */
  private async generateSchedulesForDate(
    date: Date, 
    options: ScheduleGenerationOptions
  ): Promise<AutoGeneratedSchedule[]> {
    const dayOfWeek = this.getDayOfWeek(date);
    const schedules: AutoGeneratedSchedule[] = [];

    // Skip weekends if not included
    if (!options.includeWeekends && (dayOfWeek === 'saturday' || dayOfWeek === 'sunday')) {
      return schedules;
    }

    // Get customers who prefer this day
    const availableCustomers = this.getCustomersForDay(date, dayOfWeek);
    
    // Get available crews for this day
    const availableCrews = this.getAvailableCrewsForDay(date, dayOfWeek);

    // Assign customers to crews based on:
    // 1. Geographic proximity
    // 2. Service type capabilities
    // 3. Crew capacity
    for (const [crewId, crewMembers] of availableCrews) {
      const crewCustomers = this.assignCustomersToCrew(
        availableCustomers,
        crewMembers,
        options.maxCustomersPerDay || 12
      );

      if (crewCustomers.length > 0) {
        const schedule = await this.createCrewSchedule(
          date,
          crewId,
          crewMembers,
          crewCustomers,
          options.serviceBufferMinutes || 15
        );
        schedules.push(schedule);
      }
    }

    return schedules;
  }

  /**
   * Get customers who need service on a specific day
   */
  private getCustomersForDay(date: Date, dayOfWeek: DayOfWeek): Customer[] {
    return this.customers.filter(customer => {
      // Check if customer prefers this day
      const prefersThisDay = customer.servicePreferences.preferredDays.includes(dayOfWeek);
      
      // Check if customer needs service based on frequency
      const daysSinceLastService = customer.lastServiceDate 
        ? Math.floor((date.getTime() - customer.lastServiceDate.toDate().getTime()) / (1000 * 60 * 60 * 24))
        : Infinity;
      
      const needsService = daysSinceLastService >= customer.servicePreferences.serviceFrequency;
      
      // Check if customer is active
      const isActive = customer.status === 'active';
      
      return prefersThisDay && needsService && isActive;
    });
  }

  /**
   * Get crews available for a specific day
   */
  private getAvailableCrewsForDay(date: Date, dayOfWeek: DayOfWeek): Map<string, User[]> {
    const availableCrews = new Map<string, User[]>();

    this.crews.forEach((crewMembers, crewId) => {
      const availableMembers = crewMembers.filter(member => {
        // Check if member is available on this day
        const daySchedule = member.schedule?.[dayOfWeek];
        return daySchedule?.available && member.status === 'available';
      });

      if (availableMembers.length > 0) {
        availableCrews.set(crewId, availableMembers);
      }
    });

    return availableCrews;
  }

  /**
   * Assign customers to a crew based on service type compatibility
   */
  private assignCustomersToCrew(
    customers: Customer[],
    crewMembers: User[],
    maxCustomers: number
  ): Customer[] {
    // Get crew's service types from the first member (all members should have same crewServiceTypes)
    const crewServiceTypes = crewMembers[0]?.crewServiceTypes || ['general'];

    // Filter customers by crew service types
    const compatibleCustomers = customers.filter(customer =>
      customer.services.some(service => crewServiceTypes.includes(service.type))
    );

    // Sort by priority (days since last service, customer preferences)
    const prioritizedCustomers = compatibleCustomers.sort((a, b) => {
      const aDaysSinceLast = a.lastServiceDate 
        ? Math.floor((Date.now() - a.lastServiceDate.toDate().getTime()) / (1000 * 60 * 60 * 24))
        : 0;
      const bDaysSinceLast = b.lastServiceDate 
        ? Math.floor((Date.now() - b.lastServiceDate.toDate().getTime()) / (1000 * 60 * 60 * 24))
        : 0;
      
      return bDaysSinceLast - aDaysSinceLast; // Higher priority for customers who haven't been serviced longer
    });

    // Take the first N customers (simple assignment - could be enhanced with clustering)
    return prioritizedCustomers.slice(0, maxCustomers);
  }

  /**
   * Create a schedule for a crew
   */
  private async createCrewSchedule(
    date: Date,
    crewId: string,
    crewMembers: User[],
    customers: Customer[],
    bufferMinutes: number
  ): Promise<AutoGeneratedSchedule> {
    // Calculate estimated times based on customer count and service types
    const totalServiceTime = customers.reduce((total, customer) => {
      return total + customer.services.reduce((serviceTotal, service) => {
        // Estimate 30 minutes per service type
        return serviceTotal + 30;
      }, 0);
    }, 0);

    // Add buffer time between customers
    const totalBufferTime = (customers.length - 1) * bufferMinutes;
    const totalTime = totalServiceTime + totalBufferTime;

    // Start at 8 AM (could be made configurable)
    const startTime = "08:00";
    const endTime = this.calculateEndTime(startTime, totalTime);

    // Simple route optimization (could be enhanced with Google Maps API)
    const optimizedRoute = this.optimizeRoute(customers);

    return {
      date,
      crewId,
      crewMembers,
      customers,
      estimatedStartTime: startTime,
      estimatedEndTime: endTime,
      totalDistance: this.calculateTotalDistance(optimizedRoute),
      optimizedRoute,
    };
  }

  /**
   * Calculate end time based on start time and duration
   */
  private calculateEndTime(startTime: string, totalMinutes: number): string {
    const [hours, minutes] = startTime.split(':').map(Number);
    const startDate = new Date();
    startDate.setHours(hours, minutes, 0, 0);
    
    const endDate = new Date(startDate.getTime() + totalMinutes * 60 * 1000);
    return `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;
  }

  /**
   * Simple route optimization (nearest neighbor)
   */
  private optimizeRoute(customers: Customer[]): { lat: number; lng: number }[] {
    if (customers.length === 0) return [];

    const route: { lat: number; lng: number }[] = [];
    const unvisited = [...customers];
    
    // Start with the first customer
    let current = unvisited.shift()!;
    route.push({ lat: current.lat, lng: current.lng });

    // Find nearest neighbor for each remaining customer
    while (unvisited.length > 0) {
      const nearest = this.findNearestCustomer(current, unvisited);
      const index = unvisited.indexOf(nearest);
      unvisited.splice(index, 1);
      
      route.push({ lat: nearest.lat, lng: nearest.lng });
      current = nearest;
    }

    return route;
  }

  /**
   * Find the nearest customer to a given customer
   */
  private findNearestCustomer(
    current: Customer, 
    customers: Customer[]
  ): Customer {
    let nearest = customers[0];
    let minDistance = this.calculateDistance(current, nearest);

    for (const customer of customers) {
      const distance = this.calculateDistance(current, customer);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = customer;
      }
    }

    return nearest;
  }

  /**
   * Calculate distance between two customers (Haversine formula)
   */
  private calculateDistance(a: Customer, b: Customer): number {
    const R = 6371; // Earth's radius in kilometers
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    
    const a1 = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.sin(dLng / 2) * Math.sin(dLng / 2) * Math.cos(lat1) * Math.cos(lat2);
    const c = 2 * Math.atan2(Math.sqrt(a1), Math.sqrt(1 - a1));
    
    return R * c;
  }

  /**
   * Calculate total distance of a route
   */
  private calculateTotalDistance(route: { lat: number; lng: number }[]): number {
    let totalDistance = 0;
    
    for (let i = 0; i < route.length - 1; i++) {
      const a = route[i];
      const b = route[i + 1];
      totalDistance += this.calculateDistance(
        { lat: a.lat, lng: a.lng } as Customer,
        { lat: b.lat, lng: b.lng } as Customer
      );
    }
    
    return totalDistance;
  }

  /**
   * Get day of week as string
   */
  private getDayOfWeek(date: Date): DayOfWeek {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    return days[date.getDay()] as DayOfWeek;
  }
}

// Export singleton instance
export const autoScheduleGenerator = new AutoScheduleGenerator(); 